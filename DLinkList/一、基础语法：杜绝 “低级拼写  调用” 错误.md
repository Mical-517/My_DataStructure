再对链表实施操作时要注意行动指针存在

### 一、基础语法：杜绝 “低级拼写 / 调用” 错误

这类错误是最容易避免的，但也是新手高频踩坑点，直接导致编译失败。

#### 1. 明确 “指针 / 对象” 调用规则（核心！你多次踩坑）

- 规则：**指针变量用`->`，对象 / 引用变量用`.`**，写代码时先判断变量类型，再选调用符。

  - 错误案例：`temp->head`（temp 是`const DLinkList&`对象，应写`temp.head`）；
  - 记忆技巧：指针是 “间接指向”，用`->`；对象是 “直接访问”，用`.`。

  

#### 2. 拼写 / 语法自检：写后立刻核对

- 规则：涉及变量名（如`tail/tal`）、函数名、模板参数时，写一行核对一行，避免笔误。

  - 错误案例：`this->tal`（拼写错误，应为`this->tail`）；
  - 小技巧：IDE 开启拼写检查（如 VS 的 “拼写检查器”、CLion 的 “Inspections”），能自动标红拼写错误。

  

#### 3. 模板类 / 函数：参数 / 类型不遗漏

- 规则：模板类创建对象 / 节点时，必须写全模板参数，不能省略。

  - 错误案例：`new DLNode(infor)`（应为`new DLNode<DataType>(infor)`）；
  - 原因：模板类的类型推导不是万能的，省略参数易导致编译错误或类型不匹配。

  

### 二、指针 / 内存安全：避免崩溃和内存泄漏

双向链表的核心是指针操作，这也是你出错最多的模块（空指针、野指针、链表断裂）。

#### 1. **指针操作 “先判空，再访问”**

- 规则：访问`ptr->xxx`前，先检查`ptr != nullptr`，避免空指针崩溃。

  - 错误案例：`head->next`（若 head 未初始化为 nullptr，直接访问崩溃）；

  - 落地技巧：

    

    ```
    // 析构函数中，先判空再遍历（你之前的析构优化版）
    DLNode<DataType>* current = head;
    while (current != nullptr) { // 先判空，再访问current->next
        DLNode<DataType>* next_node = current->next;
        delete current;
        current = next_node;
    }
    ```

    **在访问指针之前一定要记得检查是否是非法访问**

  

#### 2. 内存释放：“先保存，再删除”，避免断链

- 规则：删除节点 / 释放指针前，先保存后续指针，再执行删除，防止丢失链表引用。

  - 错误案例：析构函数中直接`delete pre; current=current->next;`（若 current=nullptr，访问崩溃）；

  - 落地模板（通用指针释放）：

    **这个模版很好用**

    ```
    // 通用遍历释放模板
    T* curr = start_ptr;
    while (curr != nullptr) {
        T* next = curr->next; // 先保存下一个节点
        delete curr;          // 再删除当前节点
        curr = next;          // 移动指针
    }
    ```

    **并且在delete的时候要注意这是否是nullptr**

  

#### 3. 链表节点拼接：“先连后断”，避免断裂

- 规则：新增 / 删除节点时，先更新 “后继节点的前驱” 和 “前驱节点的后继”，再修改目标节点。

  - 错误案例：erase 中只改`p->next`，未改`del_node->next->pre`，导致链表断裂；

  - 落地步骤（删除节点）：

    1. 保存待删除节点：`DLNode* del = p->next;`；
    2. 更新后继节点的 pre：`del->next->pre = p;`；
    3. 更新前驱节点的 next：`p->next = del->next;`；
    4. 删除节点：`delete del;`。

    

  

### 三、逻辑鲁棒性：处理边界条件，避免死循环 / 越界

#### 1. 循环条件：“基于有效范围”，而非 “基于指针本身”

- 规则：循环条件要明确 “有效范围”，避免遍历到无效节点（如 tail、nullptr）。

  - 错误案例：`while(p != this->tail)`（p 遍历到 tail 时，`p->next`为 nullptr，访问`p->next->data`崩溃）；
  - 正确写法：`while(p->next != this->tail)`（限定 p->next 是有效元素节点）。

  

#### 2. 空容器处理：所有操作先判空

- 规则：insert/erase/size 等函数，先判断链表是否为空，再执行逻辑，避免空链表操作崩溃。

  - 落地模板：

    

    ```
    void erase(DataType infor) {
        if (empty()) return; // 先判空，直接返回
        // 后续逻辑
    }
    ```

    

  

#### 3. 深拷贝：“初始化 + 复用已有逻辑”，避免重复造轮子

- 规则：深拷贝构造函数先初始化自身空容器，再复用 insert 等已有函数，减少重复代码和错误。

  - 错误案例：深拷贝中手动拼接节点，易漏写`next/pre`；

  - 优化写法（你的代码可进一步优化）：

    

    ```
    DLinkList(const DLinkList<DataType>& temp) {
        // 1. 初始化自身空链表
        head = new DLNode<DataType>();
        tail = new DLNode<DataType>();
        head->next = tail;
        tail->pre = head;
        number = 0;
    
        // 2. 复用insert，避免手动拼接节点
        DLNode<DataType>* temp_ptr = temp.head->next;
        while (temp_ptr != temp.tail) {
            this->insert(temp_ptr->data); // 复用尾插逻辑，减少错误
            temp_ptr = temp_ptr->next;
        }
    }
    ```

    

  

### 四、代码规范：提升可读性，减少逻辑混淆

#### 1. const 修饰：“只读函数加 const”，统一语义

- 规则：仅读取数据、不修改成员变量的函数（如 empty、size、getHeadPtr），必须加`const`修饰。

  - 错误案例：`empty()`声明为`const`，但实现时漏写`const`；
  - 好处：const 对象可调用，避免 “const 对象无法调用非 const 函数” 的编译错误，语义更清晰。

  

#### 2. 命名规范：“见名知意”，符合行业惯例

- 规则：函数 / 变量名要体现功能，避免语义混淆（你之前的 emplace/erase）。

  - 错误案例：`emplace`（C++ 惯例是 “构造并插入”，但你用来做删除，易混淆）；

  - 行业惯例（容器类）：

    - 插入：`push_back`（尾插）、`push_front`（头插）、`insert`（指定位置插）；
    - 删除：`erase`（删除指定元素）、`clear`（清空）；
    - 状态：`empty`（判空）、`size`（大小）、`begin/end`（头尾迭代器）。

    

  

#### 3. 成员变量：“初始化 + 命名区分”，避免计数不一致

- 规则：成员变量在构造函数中显式初始化，计数类变量（如 number）只在 “插入 / 删除” 时更新，避免手动赋值出错。

  - 错误案例：深拷贝中手动`number++`，易和源链表 size 不一致；
  - 优化：深拷贝直接`this->number = temp.size()`，复用已验证的计数逻辑。

  

### 五、测试驱动：提前写测试用例，早发现错误

- 规则：写核心功能（如 insert/erase）前，先写测试用例，明确预期结果，边写边测。

  - 你的问题：直到最后才写测试，导致很多逻辑错误晚发现；

  - 测试覆盖场景（必测）：

    1. 空容器操作（空链表删除、插入）；
    2. 正常插入 / 删除（存在 / 不存在元素）；
    3. 边界操作（删除最后一个元素、深拷贝后修改原容器）；
    4. 内存安全（析构后无崩溃、无野指针）。

    

  

### 六、总结：核心原则（记牢这 3 点，减少 80% 错误）

**先设计后编码**：先定接口、画流程，再写代码，避免边写边改；

1. **“先防御，再逻辑”**：所有操作先判空、先检查边界，再执行核心逻辑；
2. **“复用已有逻辑，不重复造轮子”**：深拷贝复用 insert、计数复用 size，减少手动代码；
3. **“边写边测，小步验证”**：写一个函数测一个函数，不要等全部写完再测，早发现早修复。

